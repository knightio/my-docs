# 3.事务

可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，**按顺序地串行化执行而不会被其他命令插入，不许加塞**

# **Redis事务 VS 数据库事务**

| 1.单独的隔离操作 | Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的 |
| --- | --- |
| 2.没有隔离级别的概念 | 因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了 |
| 3.不保证原子性 | Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力 |
| 4.排它性 | Redis会保证一个事务内的命令依次执行，而不会被其它命令插入 |

# 命令

- `MULTI` 标记事务开始
- `EXEC` 执行事务
    
    ```bash
    127.0.0.1:6379> multi
    OK
    127.0.0.1:6379(TX)> set k5 test
    QUEUED
    127.0.0.1:6379(TX)> set k6 test1
    QUEUED
    127.0.0.1:6379(TX)> exec
    1) OK
    2) OK
    ```
    
- `DISCARD` 取消事务，放弃执行
    
    ```bash
    127.0.0.1:6379> multi
    OK
    127.0.0.1:6379(TX)> set k3 sss
    QUEUED
    127.0.0.1:6379(TX)> discard
    OK
    ```
    
- `WATCH key [key …]` 监视一个或多个key，如果在事务执行之前，所监视的key被其他命令改动，那么事务被打断
- `UNWATCH` 取消所有key的监视

## 执行错误

- 如果在`exec` 前出现报错（语法错误等），Redis会直接返回错误，所有的命令都不会执行
- 如果在`exec` 执行后报错（运行错误），执行错误的命令不会执行，其他命令照常执行

> Redis不提供事务回滚，发生错误后，自行恢复数据库
> 

## watch

如果监视的key被其他命令改动，**整个事务**执行失败

一旦执行了exec之前加的监控锁都会被取消掉

当客户端连接丢失的时候(比如退出链接)，所有东西都会被取消监视