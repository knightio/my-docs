# 3.垃圾收集器与内存分配策略（上）

## 判断对象存活

### 引用计数法

存在引用对象时，计数器加一。计数器为零时，判定其死亡。

- 优点

  简单、高效。

- 缺点

  无法处理一些特殊情况，需要许多额外的特殊判断。如：对象间的相互调用。

  ```java
    objA.instance = objB;
    objB.instance = objA;

    objA = null;
    objB = null;
        
    Sysytem.gc(); //会被回收掉

  ```

### 可达性分析

从一系列称为“GC Roots”的根对象开始，根据引用关系向下搜索，未经过的对象即未被使用的对象。

#### GC Roots对象

- 虚拟机栈（栈帧中的本地变量表）中引用对象，如当前正在运行的方法使用到的参数、局部变量、临时变量等。
- 方法区中类静态属性应用的对象，如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，如字符常量出（String Table）里的引用。
- 在本地方法栈JNI(Native方法)引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointException、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
  
#### 引用关系

- 强引用

  `Object obj = new Object()`

- 软引用
  
  还有用，但非必须的对象。在发生内存溢出异常前，被列为回收范围内进行二次回收。`SoftReference`类实现。
  
- 弱引用

  弱于软引用。当垃圾收集器开始工作，无论当前内存是否足够，都会被回收。`WeakReference`类实现。

- 虚引用
  
  最弱的一种引用。设置虚引用关联的唯一目的是为了能在此对象被回收是收到一个系统通知。`PhantomReference`类实现。

#### 缓刑

真正宣告一个对象死亡，至少要经历两次标记过程：

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被**第一次标记**，随后进行一次筛选，筛选的条件是此对象**是否有必要执行finalize()方法**。

- 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

- 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。

finalize()方法是对象自救的最后一次机会，稍后收集器将对F-Queue中的对象进行**第二次小规模的标记**。

> 任何一个对象的finalize()方法都只会被系统**自动**调用一次

### 回收方法区

主要回收两部分内容：废弃的常量和不再使用的类型

- 废弃的常量

  没有任意地方引用的常量

- 不再使用的类型
  - 该类所有的实例都已经被回收
  - 加载该类的类加载器已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用
  
  > 并不是和对象一样，没有引用了就必然会回收。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 垃圾回收算法

### 分代收集理论

分代理论建立在两大假说之上：

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

设计者一般至少会把Java堆划分为**新生代（Young Generation）**和**老年代（Old Generation）** 两个区域。

存在问题：对象不是孤立的，对象之间会存在跨代引用。

- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。

> **针对不同分代收集类型**
>
> - 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
>   - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
>   - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
> - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
> - 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

### 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来。

缺点：

1. 执行效率不稳定
2. 内存空间的碎片化问题

![“标记-清除”算法示意图](https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-1.jpg)

### 标记-复制算法

解决标记-清除算法面对大量可回收对象时执行效率低的问题

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

缺点：

过多的空间浪费

![“标记-复制”算法示意图](https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-2.jpg)

新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。

#### Appel式回收

Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新
生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代会被“浪费”的。

> **“逃生门”**
>
> 当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

### 标记-整理算法

让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

缺点：

在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行。

![“标记-整理”算法示意图](https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-3.jpg)

是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。

## HotSpot的算法细节实现

### 根节点枚举

所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的

由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。

在HotSpot的解决方案里，是使用一组称为**OopMap**的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在**特定的位置**记录下栈里和寄存器里哪些位置是引用。

### 安全点

上文中的**特定的位置**，被称为安全点。用户程序执行时，强制要求必须执行到达安全点后才能够暂停，开始垃圾收集。

安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是**指令序列的复用**，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

> 由于安全点设置会有损耗，JIT会对安全点的设置进行优化。

#### 到达安全点方式

- 抢先式中断（Preemptive Suspension）
  
  系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。(没什么虚拟机在使用)

- 主动式中断（Voluntary Suspension）
  
  简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

  轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。

### 安全区域

用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（Safe Region）来解决。

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中**任意地方**开始垃圾收集**都是安全的**。我们也可以把安全区域看作被扩展拉伸了的安全点。

当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

### 记忆集与卡表

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的**抽象**数据结构。

> 抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。

记录精度：

- 字长精度：

  每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。

- 对象精度：
  
  每个记录精确到一个对象，该对象里有字段含有跨代指针。

- 卡精度：
  
  每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集。

卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。卡表最简单的形式可以只是一个**字节数组**，而HotSpot虚拟机确实也是这样做的。

卡表中的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数。

### 写屏障

在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。

> 不是解决并发乱序执行问题的“写屏障”

赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）。

应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用。

除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。

为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。

### 并发的可达性分析

并发的可能性分析，可能出现两种后果。一种是把原本消亡的对象错误标记为存活，其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果。

![并发出现“对象消失”问题的示意](https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-4.jpg)

> **三色标记（Tri-color Marking）**
>
> - 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是
白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
> - 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代
表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对
象不可能直接（不经过灰色对象）指向某个白色对象。
> - 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

当且仅当以下两个条件同时满足时，会产生“对象消失”的问题

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。

- 增量更新要破坏的是第一个条件
  
  当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
  
- 原始快照要破坏的是第二个条件
  
  当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

> 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过**写屏障**实现的。
