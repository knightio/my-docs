# 3.垃圾收集器与内存分配策略（下）

## 经典垃圾收集器

![HotSpot虚拟机的垃圾收集器](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-5.jpg)

> 两个收集器之间存在连线，就说明它们可以搭配使用

### Serial收集器

新生代、标记-复制算法实现、单线程、阻塞

#### 优点

- 简单而高效，是所有收集器里额外内存消耗（Memory Footprint）最小的。
- 对于单核处理器或处理器核心数较少的环境来说，由于没有线程交互的开销，可以获得最高的单线程收集效率。

### ParNew收集器

Serial收集器的多线程并行版本

除了Serial收集器外，目前只有它能与CMS收集器配合工作。

自JDK 9开始，ParNew合并入CMS。

### Parallel Scavenge收集器

从表面上看和ParNew非常相似

CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。

$$ \text{吞吐量}= \frac{ \text{运行用户代码时间} }{ \text{运行用户代码时间+运行垃圾收集时间} } $$

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

- `-XX：MaxGCPauseMillis` 控制最大垃圾收集停顿时间

  参数允许的值是一个大于0的毫秒数

  收集器将尽力保证内存回收花费的时间不超过用户设定值

- `-XX：GCTimeRatio` 直接设置吞吐量大小

  参数的值则应当是一个大于0小于100的整数，相当于吞吐量的倒数。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。

除上述两个参数之外，Parallel Scavenge收集器还有一个参数`-XX：+UseAdaptiveSizePolicy`值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（`-Xmn`）、Eden与Survivor区的比例（`-XX：SurvivorRatio`）、晋升老年代对象大小（`-XX：PretenureSizeThreshold`）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的**自适应的调节策略（GC Ergonomics）**。

自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

### Serial Old收集器

Serial Old是Serial收集器的老年代版本

#### 用途

1. 在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。
2. 作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本

基于标记-整理算法

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

基于标记-清除算法

运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：

1. 初始标记（CMS initial mark）

    STW

    标记一下GCRoots能直接关联到的对象，速度很快。

2. 并发标记（CMS concurrent mark）

    从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

3. 重新标记（CMS remark）

    STW

    为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（[增量更新](./3.垃圾收集器与内存分配策略（上）.md#并发的可达性分析)），停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

4. 并发清除（CMS concurrent sweep）

    清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

#### 缺点

- 会因为占用了一部分线程
- 无法处理“浮动垃圾”（Floating Garbage），即在并发标记和并发清除的过程中出现的新的垃圾对象。
  - 必须预留一部分空间供并发收集时的程序运作使用
  - 预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure）。然后冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。
- 基于“标记-清除”算法，会有大量空间碎片产生。
  - `-XX：+UseCMS-CompactAtFullCollection` （默认是开启的，此参数从JDK 9开始废弃）用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程.
  - `-XX：CMSFullGCsBefore-Compaction` 要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。
  
### Garbage First收集器

虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。

这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。

![G1收集器Region分区示意图](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-6.jpg)

#### 跨代引用问题

G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。

这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。

#### 并发问题

CMS收集器采用增量更新算法实现，而G1收集器则是通过**原始快照（SATB）** 算法来实现的。

G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。

如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。

#### 运作过程

如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：

- 初始标记（Initial Marking）

  标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值。需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

- 并发标记（Concurrent Marking）

  对堆中对象进行可达性分析，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

- 最终标记（Final Marking）

  对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

- 筛选回收（Live Data Counting and Evacuation）
  
  负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。

G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片

G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。

目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间

## 低延迟垃圾收集器

衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。

这三项指标里，延迟的重要性日益凸显，越发备受关注。

![各款收集器的并发情况](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-7.jpg)

> 浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。

### Shenandoah收集器

Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region

与G1至少有三个明显的不同之处:

- 支持并发的整理算法
- 默认不使用分代收集
- 摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（ConnectionMatrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。

  连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向Region M，就在表格的N行M列中打上一个标记

  ![Shenandoah收集器的连接矩阵示意图](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-8.jpg)

#### 过程

- 初始标记（Initial Marking）
  
  与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。

- 并发标记（Concurrent Marking）
  
  与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。

- 最终标记（Final Marking）

  与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。

- 并发清理（Concurrent Cleanup）
  
  这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。

- 并发回收（Concurrent Evacuation）
  
  并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。

- 初始引用更新（Initial Update Reference）
  
  并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。

- 并发引用更新（Concurrent Update Reference）
  
  真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。

- 最终引用更新（Final Update Reference）
  
  解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。

- 并发清理（Concurrent Cleanup）
  
  经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。

  ![Shenandoah收集器的工作过程](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-9.jpg)

  > 黄色的区域代表的是被选入回收集的Region  
  > 绿色部分就代表还存活的对象  
  > 蓝色就是用户线程可以用来分配对象的内存Region

#### 转发指针

在原有对象布局结构的最前面统一增加一个新的引用字段，用于指向对象地址。与[句柄定位](./2.Java内存区域与内存溢出异常.md#对象的访问定位)类似

Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。

### ZGC收集器

ZGC收集器是一款**基于Region内存布局**的，**（暂时）** 不设分代的，使用了**读屏障**、**染色指针**和**内存多重映射**等技术来实现**可并发**的**标记-整理算法**的，以**低延迟**为首要目标的一款垃圾收集器。

#### 内存布局

ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。

在x64硬件平台下，ZGC的Region可以具有如图3-19所示的大、中、小三类容量：

- 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
- 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中**只会存放一个大对象**，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。

![ZGC的堆内存布局](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-10.jpg)

#### 染色指针

染色指针是一种直接将少量额外的信息存储在指针上的技术。

