# 3.垃圾收集器与内存分配策略（下）

## 经典垃圾收集器

![HotSpot虚拟机的垃圾收集器](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-5.jpg)

> 两个收集器之间存在连线，就说明它们可以搭配使用

### Serial收集器

新生代、标记-复制算法实现、单线程、阻塞

#### 优点

- 简单而高效，是所有收集器里额外内存消耗（Memory Footprint）最小的。
- 对于单核处理器或处理器核心数较少的环境来说，由于没有线程交互的开销，可以获得最高的单线程收集效率。

### ParNew收集器

Serial收集器的多线程并行版本

除了Serial收集器外，目前只有它能与CMS收集器配合工作。

自JDK 9开始，ParNew合并入CMS。

### Parallel Scavenge收集器

从表面上看和ParNew非常相似

CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。

$$ \text{吞吐量}= \frac{ \text{运行用户代码时间} }{ \text{运行用户代码时间+运行垃圾收集时间} } $$

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

- `-XX：MaxGCPauseMillis` 控制最大垃圾收集停顿时间

  参数允许的值是一个大于0的毫秒数

  收集器将尽力保证内存回收花费的时间不超过用户设定值

- `-XX：GCTimeRatio` 直接设置吞吐量大小

  参数的值则应当是一个大于0小于100的整数，相当于吞吐量的倒数。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。

除上述两个参数之外，Parallel Scavenge收集器还有一个参数`-XX：+UseAdaptiveSizePolicy`值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（`-Xmn`）、Eden与Survivor区的比例（`-XX：SurvivorRatio`）、晋升老年代对象大小（`-XX：PretenureSizeThreshold`）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的**自适应的调节策略（GC Ergonomics）**。

自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

### Serial Old收集器

Serial Old是Serial收集器的老年代版本

#### 用途

1. 在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。
2. 作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本

基于标记-整理算法

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

基于标记-清除算法

运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）
