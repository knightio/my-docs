# 3.垃圾收集器与内存分配策略（下）

## 经典垃圾收集器

![HotSpot虚拟机的垃圾收集器](https://cos.becurious.cn/Java/JVM/UTJVM/jvm3-5.jpg)

> 两个收集器之间存在连线，就说明它们可以搭配使用

### Serial收集器

新生代、标记-复制算法实现、单线程、阻塞

#### 优点

- 简单而高效，是所有收集器里额外内存消耗（Memory Footprint）最小的。
- 对于单核处理器或处理器核心数较少的环境来说，由于没有线程交互的开销，可以获得最高的单线程收集效率。

### ParNew收集器

Serial收集器的多线程并行版本

除了Serial收集器外，目前只有它能与CMS收集器配合工作。

自JDK 9开始，ParNew合并入CMS。

### Parallel Scavenge收集器

从表面上看和ParNew非常相似

CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。

$$ \text{吞吐量}= \frac{ \text{运行用户代码时间} }{ \text{运行用户代码时间+运行垃圾收集时间} } $$

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

- `-XX：MaxGCPauseMillis` 控制最大垃圾收集停顿时间

  参数允许的值是一个大于0的毫秒数

  收集器将尽力保证内存回收花费的时间不超过用户设定值

- `-XX：GCTimeRatio` 直接设置吞吐量大小

  参数的值则应当是一个大于0小于100的整数，相当于吞吐量的倒数。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。

除上述两个参数之外，Parallel Scavenge收集器还有一个参数`-XX：+UseAdaptiveSizePolicy`值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（`-Xmn`）、Eden与Survivor区的比例（`-XX：SurvivorRatio`）、晋升老年代对象大小（`-XX：PretenureSizeThreshold`）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的**自适应的调节策略（GC Ergonomics）**。

自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

### Serial Old收集器

Serial Old是Serial收集器的老年代版本

#### 用途

1. 在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。
2. 作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本

基于标记-整理算法

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

基于标记-清除算法

运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：

1. 初始标记（CMS initial mark）

    STW

    标记一下GCRoots能直接关联到的对象，速度很快。

2. 并发标记（CMS concurrent mark）

    从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

3. 重新标记（CMS remark）

    STW

    为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（[增量更新](./3.垃圾收集器与内存分配策略（上）.md#并发的可达性分析)），停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

4. 并发清除（CMS concurrent sweep）

    清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

#### 缺点

- 会因为占用了一部分线程
- 无法处理“浮动垃圾”（Floating Garbage），即在并发标记和并发清除的过程中出现的新的垃圾对象。
  - 必须预留一部分空间供并发收集时的程序运作使用
  - 预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure）。然后冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。
- 基于“标记-清除”算法，会有大量空间碎片产生。
  - `-XX：+UseCMS-CompactAtFullCollection` （默认是开启的，此参数从JDK 9开始废弃）用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程.
  - `-XX：CMSFullGCsBefore-Compaction` 要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。
  
### Garbage First收集器

虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。

![G1收集器Region分区示意图](https://cos.becurious.cn/Java/JVM/UTJVMjvm3-6.jpg)