# 判断对象存活

## 引用计数法

存在引用对象时，计数器加一。计数器为零时，判定其死亡。

- 优点

  简单、高效。

- 缺点

  无法处理一些特殊情况，需要许多额外的特殊判断。如：对象间的相互调用。

  ```java
    objA.instance = objB;
    objB.instance = objA;

    objA = null;
    objB = null;
        
    Sysytem.gc(); //会被回收掉

  ```

## 可达性分析

从一系列称为“GC Roots”的根对象开始，根据引用关系向下搜索，未经过的对象即未被使用的对象。

### GC Roots对象

- 虚拟机栈（栈帧中的本地变量表）中引用对象，如当前正在运行的方法使用到的参数、局部变量、临时变量等。
- 方法区中类静态属性应用的对象，如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，如字符常量出（String Table）里的引用。
- 在本地方法栈JNI(Native方法)引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointException、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
  
### 引用关系

- 强引用

  `Object obj = new Object()`

- 软引用
  
  还有用，但非必须的对象。在发生内存溢出异常前，被列为回收范围内进行二次回收。`SoftReference`类实现。
  
- 弱引用

  弱于软引用。当垃圾收集器开始工作，无论当前内存是否足够，都会被回收。`WeakReference`类实现。

- 虚引用
  
  最弱的一种引用。设置虚引用关联的唯一目的是为了能在此对象被回收是收到一个系统通知。`PhantomReference`类实现。

### 缓刑


