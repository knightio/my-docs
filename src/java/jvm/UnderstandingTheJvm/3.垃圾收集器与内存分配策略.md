# 3.垃圾收集器与内存分配策略

## 判断对象存活

### 引用计数法

存在引用对象时，计数器加一。计数器为零时，判定其死亡。

- 优点

  简单、高效。

- 缺点

  无法处理一些特殊情况，需要许多额外的特殊判断。如：对象间的相互调用。

  ```java
    objA.instance = objB;
    objB.instance = objA;

    objA = null;
    objB = null;
        
    Sysytem.gc(); //会被回收掉

  ```

### 可达性分析

从一系列称为“GC Roots”的根对象开始，根据引用关系向下搜索，未经过的对象即未被使用的对象。

#### GC Roots对象

- 虚拟机栈（栈帧中的本地变量表）中引用对象，如当前正在运行的方法使用到的参数、局部变量、临时变量等。
- 方法区中类静态属性应用的对象，如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，如字符常量出（String Table）里的引用。
- 在本地方法栈JNI(Native方法)引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointException、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
  
#### 引用关系

- 强引用

  `Object obj = new Object()`

- 软引用
  
  还有用，但非必须的对象。在发生内存溢出异常前，被列为回收范围内进行二次回收。`SoftReference`类实现。
  
- 弱引用

  弱于软引用。当垃圾收集器开始工作，无论当前内存是否足够，都会被回收。`WeakReference`类实现。

- 虚引用
  
  最弱的一种引用。设置虚引用关联的唯一目的是为了能在此对象被回收是收到一个系统通知。`PhantomReference`类实现。

#### 缓刑

真正宣告一个对象死亡，至少要经历两次标记过程：

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被**第一次标记**，随后进行一次筛选，筛选的条件是此对象**是否有必要执行finalize()方法**。

- 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

- 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。

finalize()方法是对象自救的最后一次机会，稍后收集器将对F-Queue中的对象进行**第二次小规模的标记**。

> 任何一个对象的finalize()方法都只会被系统**自动**调用一次

### 回收方法区

主要回收两部分内容：废弃的常量和不再使用的类型

- 废弃的常量

  没有任意地方引用的常量

- 不再使用的类型
  - 该类所有的实例都已经被回收
  - 加载该类的类加载器已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用
  
  > 并不是和对象一样，没有引用了就必然会回收。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 垃圾回收算法

### 分代收集理论

分代理论建立在两大假说之上：

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

存在问题：对象不是孤立的，对象之间会存在跨代引用。

3. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

