import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as n,o as i}from"./app-CxCOPEY5.js";const l={};function d(r,e){return i(),s("div",null,e[0]||(e[0]=[n(`<h1 id="_2-redis持久化" tabindex="-1"><a class="header-anchor" href="#_2-redis持久化"><span>2.Redis持久化</span></a></h1><h1 id="rdb-redis-database" tabindex="-1"><a class="header-anchor" href="#rdb-redis-database"><span><strong>RDB</strong> (Redis Database)</span></a></h1><p>RDB持久化以指定的时间间隔执行数据集的时间点快照</p><h2 id="自动触发" tabindex="-1"><a class="header-anchor" href="#自动触发"><span>自动触发</span></a></h2><h3 id="配置" tabindex="-1"><a class="header-anchor" href="#配置"><span>配置</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>save <span class="token number">60</span> <span class="token number">1000</span>
<span class="token function">dir</span> ./
dbfilename dump6379.rdb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>save &lt;seconds&gt; &lt;changes&gt;</code> 如果seconds秒更新changes个key就保存 <code>dir</code> 修改备份路径 <code>dbfilename</code> 修改备份文件名称</p></blockquote><h2 id="手动触发" tabindex="-1"><a class="header-anchor" href="#手动触发"><span>手动触发</span></a></h2><ul><li><code>save</code> 在主程序中执行会<strong>阻塞</strong>当前redis服务器，直到持久化工作完成执行save命令期间，Redis不能处理其他命令，<strong>线上禁止使用</strong></li><li><code>bgsave</code> redis会在后台异步进行快照操作，<strong>不阻塞</strong>快照同时还可以相应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程</li><li><code>LASTSAVE</code> 获取最后一次成功执行快照的时间戳</li></ul><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li>可以有不同时间段的多重备份</li><li>适合大规模的数据恢复</li><li>按照业务定时备份</li><li>对数据完整性和一致性要求不高</li><li>RDB文件在内存中的加载速度要比AOF快很多</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li><li>内存数据的全量同步，如果数据量太大会导致IO严重影响服务器性能</li><li>RDB依赖于主进程的fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><h3 id="修复rdb快照文件" tabindex="-1"><a class="header-anchor" href="#修复rdb快照文件"><span>修复<strong>RDB</strong>快照文件</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>redis-check-rdb ./redisconfig/dump.rdb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="触发rdb快照情况" tabindex="-1"><a class="header-anchor" href="#触发rdb快照情况"><span><strong>触发RDB快照情况</strong></span></a></h2><ol><li>配置文件中默认的快照配置</li><li>手动save/bgsave命令</li><li>执行flushdb/fulshall命令也会产生dump.rdb文件，但是也会将命令记录到dump.rdb文件中，恢复后依旧是空，无意义</li><li>执行shutdown且没有设置开启AOF持久化</li><li>主从复制时，主节点自动触发</li></ol><h1 id="aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file"><span><strong>AOF(Append Only File)</strong></span></a></h1><p>以日志的形式来记录每个写操作</p><h2 id="aof持久化工作流程" tabindex="-1"><a class="header-anchor" href="#aof持久化工作流程"><span><strong>AOF持久化工作流程</strong></span></a></h2><figure><img src="https://docs-r2.hanhan12.cc/Redis/2-1.png" alt="AOF持久化工作流程" tabindex="0" loading="lazy"><figcaption>AOF持久化工作流程</figcaption></figure><ol><li>Client作为命令的来源，会有多个源头以及源源不断的请求命令。</li><li>在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。</li><li>AOF缓冲会根据AOF缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的AOF文件。</li><li>随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(<strong>又称AOF重写</strong>)，从而起到AOF文件压缩的目的。</li><li>当Redis Server服务器重启的时候会队AOF文件载入数据</li></ol><h2 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件"><span>配置文件</span></a></h2><h2 id="开启" tabindex="-1"><a class="header-anchor" href="#开启"><span>开启</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>appendonly <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="写回策略" tabindex="-1"><a class="header-anchor" href="#写回策略"><span><strong>写回策略</strong></span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># appendfsync always</span>
appendfsync everysec
<span class="token comment"># appendfsync no</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ALways</strong>：同步写回，每个写命令执行完立刻同步地将日志写会磁盘</p><p><strong>everysec</strong>：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔1秒把缓冲区中的内容写入到磁盘</p><p><strong>no</strong>：操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</p><h2 id="保存路径" tabindex="-1"><a class="header-anchor" href="#保存路径"><span>保存路径</span></a></h2><h3 id="redis6" tabindex="-1"><a class="header-anchor" href="#redis6"><span>redis6</span></a></h3><p>RDB同级目录</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">dir</span> ./
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="redis7" tabindex="-1"><a class="header-anchor" href="#redis7"><span>redis7</span></a></h3><p>dir + appenddirname</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">dir</span> ./
appenddirname <span class="token string">&quot;appendonlydir&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="文件名" tabindex="-1"><a class="header-anchor" href="#文件名"><span>文件名</span></a></h2><h3 id="redis6-1" tabindex="-1"><a class="header-anchor" href="#redis6-1"><span>redis6</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>appendfilename <span class="token string">&quot;appendonly.aof&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="redis7-1" tabindex="-1"><a class="header-anchor" href="#redis7-1"><span>redis7</span></a></h3><p>使用多AOF机制，由一个基础文件和多个增量文件</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># - appendonly.aof.1.base.rdb as a base file.</span>
<span class="token comment"># - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files.</span>
<span class="token comment"># - appendonly.aof.manifest as a manifest file.</span>

appendonly.aof.1.base.rdb
appendonly.aof.1.incr.aof
appendonly.aof.2.incr.aof
appendonly.aof.manifest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>MP-AOF实现</strong> <strong>方案概述</strong> 顾名思义，MP-AOF就是将原来的单个AOF文件拆分成多个AOF文件。在MP-AOF中，我们将AOF分为三种类型, 分别为:</p><ul><li><strong>BASE: 表示基础AOF</strong>，它一般由子进程通过重写产生，该文件最多只有一个。</li><li><strong>INCR:表示增量AOF</strong>，它一般会在AOFRW开始执行时被创建，该文件可能存在多个。</li><li><strong>HISTORY</strong>:表示历史AOF，它由BASE和INCR AOF变化而来，每次AOFRW成功完成时，本次AOFRW之前对应的BASE和INCR AOF都将变为HISTORY，HISTORY类型的AOF会被Redis自动删除。</li></ul><p>为了管理这些AOF文件，我们引入了一个manifest (清单)文件来跟踪、管理这些AOF。</p><h2 id="修复aof文件" tabindex="-1"><a class="header-anchor" href="#修复aof文件"><span>修复AOF文件</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>redis-check-aof <span class="token parameter variable">--fix</span> file.aof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="优缺点-1" tabindex="-1"><a class="header-anchor" href="#优缺点-1"><span>优缺点</span></a></h2><h3 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1"><span>优点</span></a></h3><p>更好的保护数据不丢失、性能高、可做紧急恢复</p><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1"><span>缺点</span></a></h3><p>相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB</p><p>AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同</p><h2 id="重写机制" tabindex="-1"><a class="header-anchor" href="#重写机制"><span>重写机制</span></a></h2><p>启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。</p><h3 id="配置文件-1" tabindex="-1"><a class="header-anchor" href="#配置文件-1"><span>配置文件</span></a></h3><ul><li><p>自动触发</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>auto-aof-rewrite-percentage <span class="token number">100</span>
auto-aof-rewrite-min-size 64mb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>根据上次重写的大小，判断当前aof文件是否增长了100%，且大小超过64mb</p></li><li><p>手动触发</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>bgrewriteaof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="重写原理" tabindex="-1"><a class="header-anchor" href="#重写原理"><span>重写原理</span></a></h3><ol><li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li><li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</li><li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li><li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li><li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li></ol><p><strong>AOF文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的AOF文件</strong></p><h1 id="rdb-aof混合持久化" tabindex="-1"><a class="header-anchor" href="#rdb-aof混合持久化"><span><strong>RDB-AOF混合持久化</strong></span></a></h1><p><strong>RDB和AOF共存时会优先加载AOF文件</strong></p><h2 id="配置文件-2" tabindex="-1"><a class="header-anchor" href="#配置文件-2"><span>配置文件</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>aof-use-rdb-preamble <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>RDB镜像做全量持久化，AOF做增量持久化 先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录</p><h1 id="纯缓存模式" tabindex="-1"><a class="header-anchor" href="#纯缓存模式"><span>纯缓存模式</span></a></h1><p>不备份，关闭RDB、AOF</p><h3 id="关闭rdb" tabindex="-1"><a class="header-anchor" href="#关闭rdb"><span>关闭RDB</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>save <span class="token string">&quot;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>禁用RDB持久化模式下，我们仍然可以使用命令save、bgsave生成RDB文件</p><h3 id="关闭aof" tabindex="-1"><a class="header-anchor" href="#关闭aof"><span>关闭AOF</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>appendonly no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>禁用AOF持久化模式下，我们仍然可以使用命令bgrewriteaof生成AOF文件</p>`,76)]))}const c=a(l,[["render",d],["__file","2.持久化.html.vue"]]),h=JSON.parse('{"path":"/dbs/redis/2.%E6%8C%81%E4%B9%85%E5%8C%96.html","title":"持久化","lang":"zh-CN","frontmatter":{"title":"持久化","order":3,"description":"2.Redis持久化 RDB (Redis Database) RDB持久化以指定的时间间隔执行数据集的时间点快照 自动触发 配置 save <seconds> <changes> 如果seconds秒更新changes个key就保存 dir 修改备份路径 dbfilename 修改备份文件名称 手动触发 save 在主程序中执行会阻塞当前redis服...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/my-docs/dbs/redis/2.%E6%8C%81%E4%B9%85%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"一切为了更好的自己"}],["meta",{"property":"og:title","content":"持久化"}],["meta",{"property":"og:description","content":"2.Redis持久化 RDB (Redis Database) RDB持久化以指定的时间间隔执行数据集的时间点快照 自动触发 配置 save <seconds> <changes> 如果seconds秒更新changes个key就保存 dir 修改备份路径 dbfilename 修改备份文件名称 手动触发 save 在主程序中执行会阻塞当前redis服..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docs-r2.hanhan12.cc/Redis/2-1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-02T05:37:18.000Z"}],["meta",{"property":"article:author","content":"憨憨十二"}],["meta",{"property":"article:modified_time","content":"2024-09-02T05:37:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"持久化\\",\\"image\\":[\\"https://docs-r2.hanhan12.cc/Redis/2-1.png\\"],\\"dateModified\\":\\"2024-09-02T05:37:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"憨憨十二\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"自动触发","slug":"自动触发","link":"#自动触发","children":[{"level":3,"title":"配置","slug":"配置","link":"#配置","children":[]}]},{"level":2,"title":"手动触发","slug":"手动触发","link":"#手动触发","children":[]},{"level":2,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[{"level":3,"title":"修复RDB快照文件","slug":"修复rdb快照文件","link":"#修复rdb快照文件","children":[]}]},{"level":2,"title":"触发RDB快照情况","slug":"触发rdb快照情况","link":"#触发rdb快照情况","children":[]},{"level":2,"title":"AOF持久化工作流程","slug":"aof持久化工作流程","link":"#aof持久化工作流程","children":[]},{"level":2,"title":"配置文件","slug":"配置文件","link":"#配置文件","children":[]},{"level":2,"title":"开启","slug":"开启","link":"#开启","children":[]},{"level":2,"title":"写回策略","slug":"写回策略","link":"#写回策略","children":[]},{"level":2,"title":"保存路径","slug":"保存路径","link":"#保存路径","children":[{"level":3,"title":"redis6","slug":"redis6","link":"#redis6","children":[]},{"level":3,"title":"redis7","slug":"redis7","link":"#redis7","children":[]}]},{"level":2,"title":"文件名","slug":"文件名","link":"#文件名","children":[{"level":3,"title":"redis6","slug":"redis6-1","link":"#redis6-1","children":[]},{"level":3,"title":"redis7","slug":"redis7-1","link":"#redis7-1","children":[]}]},{"level":2,"title":"修复AOF文件","slug":"修复aof文件","link":"#修复aof文件","children":[]},{"level":2,"title":"优缺点","slug":"优缺点-1","link":"#优缺点-1","children":[{"level":3,"title":"优点","slug":"优点-1","link":"#优点-1","children":[]},{"level":3,"title":"缺点","slug":"缺点-1","link":"#缺点-1","children":[]}]},{"level":2,"title":"重写机制","slug":"重写机制","link":"#重写机制","children":[{"level":3,"title":"配置文件","slug":"配置文件-1","link":"#配置文件-1","children":[]},{"level":3,"title":"重写原理","slug":"重写原理","link":"#重写原理","children":[]}]},{"level":2,"title":"配置文件","slug":"配置文件-2","link":"#配置文件-2","children":[{"level":3,"title":"关闭RDB","slug":"关闭rdb","link":"#关闭rdb","children":[]},{"level":3,"title":"关闭AOF","slug":"关闭aof","link":"#关闭aof","children":[]}]}],"git":{"createdTime":1695377321000,"updatedTime":1725255438000,"contributors":[{"name":"consen3464","email":"wangkai@consen.net","commits":2}]},"readingTime":{"minutes":6.32,"words":1896},"filePathRelative":"dbs/redis/2.持久化.md","localizedDate":"2023年9月22日","autoDesc":true}');export{c as comp,h as data};
