import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,e as r,a as e,b as a,d as i,w as o,r as p,o as s}from"./app-CuAYvg6V.js";const c={};function g(h,t){const n=p("RouteLink");return s(),l("div",null,[t[11]||(t[11]=r('<h1 id="_3-垃圾收集器与内存分配策略-下" tabindex="-1"><a class="header-anchor" href="#_3-垃圾收集器与内存分配策略-下"><span>3.垃圾收集器与内存分配策略（下）</span></a></h1><h2 id="经典垃圾收集器" tabindex="-1"><a class="header-anchor" href="#经典垃圾收集器"><span>经典垃圾收集器</span></a></h2><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-5.jpg" alt="HotSpot虚拟机的垃圾收集器" tabindex="0" loading="lazy"><figcaption>HotSpot虚拟机的垃圾收集器</figcaption></figure><blockquote><p>两个收集器之间存在连线，就说明它们可以搭配使用</p></blockquote><h3 id="serial收集器" tabindex="-1"><a class="header-anchor" href="#serial收集器"><span>Serial收集器</span></a></h3><p>新生代、标记-复制算法实现、单线程、阻塞</p><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h4><ul><li>简单而高效，是所有收集器里额外内存消耗（Memory Footprint）最小的。</li><li>对于单核处理器或处理器核心数较少的环境来说，由于没有线程交互的开销，可以获得最高的单线程收集效率。</li></ul><h3 id="parnew收集器" tabindex="-1"><a class="header-anchor" href="#parnew收集器"><span>ParNew收集器</span></a></h3><p>Serial收集器的多线程并行版本</p><p>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>自JDK 9开始，ParNew合并入CMS。</p><h3 id="parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge收集器"><span>Parallel Scavenge收集器</span></a></h3><p>从表面上看和ParNew非常相似</p><p>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。</p><p>$$ \\text{吞吐量}= \\frac{ \\text{运行用户代码时间} }{ \\text{运行用户代码时间+运行垃圾收集时间} } $$</p><p>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量</p><ul><li><p><code>-XX：MaxGCPauseMillis</code> 控制最大垃圾收集停顿时间</p><p>参数允许的值是一个大于0的毫秒数</p><p>收集器将尽力保证内存回收花费的时间不超过用户设定值</p></li><li><p><code>-XX：GCTimeRatio</code> 直接设置吞吐量大小</p><p>参数的值则应当是一个大于0小于100的整数，相当于吞吐量的倒数。</p></li></ul><p>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。</p><p>除上述两个参数之外，Parallel Scavenge收集器还有一个参数<code>-XX：+UseAdaptiveSizePolicy</code>值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（<code>-Xmn</code>）、Eden与Survivor区的比例（<code>-XX：SurvivorRatio</code>）、晋升老年代对象大小（<code>-XX：PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的<strong>自适应的调节策略（GC Ergonomics）</strong>。</p><p>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</p><h3 id="serial-old收集器" tabindex="-1"><a class="header-anchor" href="#serial-old收集器"><span>Serial Old收集器</span></a></h3><p>Serial Old是Serial收集器的老年代版本</p><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途"><span>用途</span></a></h4><ol><li>在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。</li><li>作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li></ol><h3 id="parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old收集器"><span>Parallel Old收集器</span></a></h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本</p><p>基于标记-整理算法</p><p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p><h3 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器"><span>CMS收集器</span></a></h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>基于标记-清除算法</p><p>运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：</p>',34)),e("ol",null,[t[5]||(t[5]=e("li",null,[e("p",null,"初始标记（CMS initial mark）"),e("p",null,"STW"),e("p",null,"标记一下GCRoots能直接关联到的对象，速度很快。")],-1)),t[6]||(t[6]=e("li",null,[e("p",null,"并发标记（CMS concurrent mark）"),e("p",null,"从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。")],-1)),e("li",null,[t[3]||(t[3]=e("p",null,"重新标记（CMS remark）",-1)),t[4]||(t[4]=e("p",null,"STW",-1)),e("p",null,[t[1]||(t[1]=a("为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（")),i(n,{to:"/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8A%EF%BC%89.html#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"},{default:o(()=>t[0]||(t[0]=[a("增量更新")])),_:1,__:[0]}),t[2]||(t[2]=a("），停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。"))])]),t[7]||(t[7]=e("li",null,[e("p",null,"并发清除（CMS concurrent sweep）"),e("p",null,"清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。")],-1))]),t[12]||(t[12]=r('<h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h4><ul><li>会因为占用了一部分线程</li><li>无法处理“浮动垃圾”（Floating Garbage），即在并发标记和并发清除的过程中出现的新的垃圾对象。 <ul><li>必须预留一部分空间供并发收集时的程序运作使用</li><li>预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure）。然后冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li></ul></li><li>基于“标记-清除”算法，会有大量空间碎片产生。 <ul><li><code>-XX：+UseCMS-CompactAtFullCollection</code> （默认是开启的，此参数从JDK 9开始废弃）用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程.</li><li><code>-XX：CMSFullGCsBefore-Compaction</code> 要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。</li></ul></li></ul><h3 id="garbage-first收集器" tabindex="-1"><a class="header-anchor" href="#garbage-first收集器"><span>Garbage First收集器</span></a></h3><p>虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。</p><p>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-6.jpg" alt="G1收集器Region分区示意图" tabindex="0" loading="lazy"><figcaption>G1收集器Region分区示意图</figcaption></figure><h4 id="跨代引用问题" tabindex="-1"><a class="header-anchor" href="#跨代引用问题"><span>跨代引用问题</span></a></h4><p>G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。</p><p>这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。</p><h4 id="并发问题" tabindex="-1"><a class="header-anchor" href="#并发问题"><span>并发问题</span></a></h4><p>CMS收集器采用增量更新算法实现，而G1收集器则是通过<strong>原始快照（SATB）</strong> 算法来实现的。</p><p>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</p><p>如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。</p><h4 id="运作过程" tabindex="-1"><a class="header-anchor" href="#运作过程"><span>运作过程</span></a></h4><p>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：</p><ul><li><p>初始标记（Initial Marking）</p><p>标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值。需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p></li><li><p>并发标记（Concurrent Marking）</p><p>对堆中对象进行可达性分析，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p></li><li><p>最终标记（Final Marking）</p><p>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p></li><li><p>筛选回收（Live Data Counting and Evacuation）</p><p>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p></li></ul><p>设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。</p><p>G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片</p><p>G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p><p>目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</p><h2 id="低延迟垃圾收集器" tabindex="-1"><a class="header-anchor" href="#低延迟垃圾收集器"><span>低延迟垃圾收集器</span></a></h2><p>衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。</p><p>这三项指标里，延迟的重要性日益凸显，越发备受关注。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-7.jpg" alt="各款收集器的并发情况" tabindex="0" loading="lazy"><figcaption>各款收集器的并发情况</figcaption></figure><blockquote><p>浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。</p></blockquote><h3 id="shenandoah收集器" tabindex="-1"><a class="header-anchor" href="#shenandoah收集器"><span>Shenandoah收集器</span></a></h3><p>Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region</p><p>与G1至少有三个明显的不同之处:</p><ul><li><p>支持并发的整理算法</p></li><li><p>默认不使用分代收集</p></li><li><p>摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（ConnectionMatrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</p><p>连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向Region M，就在表格的N行M列中打上一个标记</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-8.jpg" alt="Shenandoah收集器的连接矩阵示意图" tabindex="0" loading="lazy"><figcaption>Shenandoah收集器的连接矩阵示意图</figcaption></figure></li></ul><h4 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h4><ul><li><p>初始标记（Initial Marking）</p><p>与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。</p></li><li><p>并发标记（Concurrent Marking）</p><p>与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</p></li><li><p>最终标记（Final Marking）</p><p>与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。</p></li><li><p>并发清理（Concurrent Cleanup）</p><p>这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。</p></li><li><p>并发回收（Concurrent Evacuation）</p><p>并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。</p></li><li><p>初始引用更新（Initial Update Reference）</p><p>并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。</p></li><li><p>并发引用更新（Concurrent Update Reference）</p><p>真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</p></li><li><p>最终引用更新（Final Update Reference）</p><p>解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。</p></li><li><p>并发清理（Concurrent Cleanup）</p><p>经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-9.jpg" alt="Shenandoah收集器的工作过程" tabindex="0" loading="lazy"><figcaption>Shenandoah收集器的工作过程</figcaption></figure><blockquote><p>黄色的区域代表的是被选入回收集的Region<br> 绿色部分就代表还存活的对象<br> 蓝色就是用户线程可以用来分配对象的内存Region</p></blockquote></li></ul><h4 id="转发指针" tabindex="-1"><a class="header-anchor" href="#转发指针"><span>转发指针</span></a></h4>',33)),e("p",null,[t[9]||(t[9]=a("在原有对象布局结构的最前面统一增加一个新的引用字段，用于指向对象地址。与")),i(n,{to:"/books/UnderStandingTheJvm/2.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"},{default:o(()=>t[8]||(t[8]=[a("句柄定位")])),_:1,__:[8]}),t[10]||(t[10]=a("类似"))]),t[13]||(t[13]=r('<p>Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。</p><h3 id="zgc收集器" tabindex="-1"><a class="header-anchor" href="#zgc收集器"><span>ZGC收集器</span></a></h3><p>ZGC收集器是一款<strong>基于Region内存布局</strong>的，<strong>（暂时）</strong> 不设分代的，使用了<strong>读屏障</strong>、<strong>染色指针</strong>和<strong>内存多重映射</strong>等技术来实现<strong>可并发</strong>的<strong>标记-整理算法</strong>的，以<strong>低延迟</strong>为首要目标的一款垃圾收集器。</p><h4 id="内存布局" tabindex="-1"><a class="header-anchor" href="#内存布局"><span>内存布局</span></a></h4><p>ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。</p><p>在x64硬件平台下，ZGC的Region可以具有如图3-19所示的大、中、小三类容量：</p><ul><li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li><li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li><li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中<strong>只会存放一个大对象</strong>，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。</li></ul><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-10.jpg" alt="ZGC的堆内存布局" tabindex="0" loading="lazy"><figcaption>ZGC的堆内存布局</figcaption></figure><h4 id="染色指针" tabindex="-1"><a class="header-anchor" href="#染色指针"><span>染色指针</span></a></h4><p>染色指针是一种直接将少量额外的信息存储在指针上的技术。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-11.jpg" alt="染色指针示意" tabindex="0" loading="lazy"><figcaption>染色指针示意</figcaption></figure><p>三大优势：</p><ul><li><p>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理</p></li><li><p>大幅减少在垃圾收集过程中内存屏障的使用数量</p><p>到目前为止ZGC都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。</p></li><li><p>可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能</p></li></ul><blockquote><p><strong>多重映射</strong></p><p>Linux/x86-64平台上的ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了</p></blockquote><h4 id="流程-todo" tabindex="-1"><a class="header-anchor" href="#流程-todo"><span>流程 todo</span></a></h4><ul><li><p>并发标记（Concurrent Mark）</p><p>与G1、Shenandoah不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。</p></li><li><p>并发预备重分配（Concurrent Prepare for Relocate）</p><p>需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。</p></li><li><p>并发重分配（Concurrent Relocate）</p><p>重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（ForwardTable），记录从旧对象到新对象的转向关系。</p></li><li><p>并发重映射（Concurrent Remap）</p></li></ul><h2 id="选择合适的垃圾收集器" tabindex="-1"><a class="header-anchor" href="#选择合适的垃圾收集器"><span>选择合适的垃圾收集器</span></a></h2><h3 id="epsilon收集器" tabindex="-1"><a class="header-anchor" href="#epsilon收集器"><span>Epsilon收集器</span></a></h3><p>Epsilon被形容成一个无操作的收集器（A No-Op Garbage Collector）</p><h3 id="收集器的权衡" tabindex="-1"><a class="header-anchor" href="#收集器的权衡"><span>收集器的权衡</span></a></h3><ul><li>应用程序的主要关注点 <ul><li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点</li><li>如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点</li><li>如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的</li></ul></li></ul><h3 id="虚拟机及垃圾收集器日志" tabindex="-1"><a class="header-anchor" href="#虚拟机及垃圾收集器日志"><span>虚拟机及垃圾收集器日志</span></a></h3><p>HotSpot所有功能的日志都收归到了“-Xlog”参数上 <strong>(JDK9)</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="selector" tabindex="-1"><a class="header-anchor" href="#selector"><span>selector</span></a></h4><p>命令行中最关键的参数是选择器（Selector），它由标签（Tag）和日志级别（Level）共同组成。</p><p>垃圾收集器的标签名称为“gc”</p><blockquote><p>HotSpot众多功能日志的其中一项，全部支持的功能模块标签名如下所示</p><p>add，age，alloc，annotation，aot，arguments，attach，barrier，biasedlocking，blocks，bot，breakpoint，bytecode，census，class，classhisto，cleanup，compaction，comparator，constraints，constantpool，coops，cpu，cset，data，defaultmethods，dump，ergo，event，exceptions，exit，fingerprint，freelist，gc，hashtables，heap，humongous，ihop，iklass，init，itables，jfr，jni，jvmti，liveness，load，loader，logging，mark，marking，metadata，metaspace，method，mmu，modules，monitorinflation，monitormismatch，nmethod，normalize，objecttagging，obsolete，oopmap，os，pagesize，parser，patch，path，phases，plab，preorder，promotion，protectiondomain，purge，redefine，ref，refine，region，remset，resolve，safepoint，scavenge，scrub，setting，stackmap，stacktrace，stackwalk，start，startuptime，state，stats，stringdedup，stringtable，subclass，survivor，sweep，system，task，thread，time，timer，tlab，unload，update，verification，verify，vmoperation，vtables，workgang</p></blockquote><p>日志级别从低到高，共有Trace，Debug，Info，Warning，Error，Off六种级别:还可以使用修饰器（Decorator）来要求每行日志输出都附加上额外的内容，支持附加在日志行上的信息包括：</p><ul><li>time：当前日期和时间。</li><li>uptime：虚拟机启动到现在经过的时间，以秒为单位。</li><li>timemillis：当前时间的毫秒数，相当于System.currentTimeMillis()的输出。</li><li>uptimemillis：虚拟机启动到现在经过的毫秒数。</li><li>timenanos：当前时间的纳秒数，相当于System.nanoTime()的输出。</li><li>uptimenanos：虚拟机启动到现在经过的纳秒数。</li><li>pid：进程ID。</li><li>tid：线程ID。</li><li>level：日志级别。</li><li>tags：日志输出的标签集。</li></ul><p>如果不指定，默认值是uptime、level、tags</p><h4 id="参数使用" tabindex="-1"><a class="header-anchor" href="#参数使用"><span>参数使用</span></a></h4><table><thead><tr><th>JDK 9前日志参数</th><th>JDK 9后配置形式</th><th></th></tr></thead><tbody><tr><td>G1PrintHeapRegions</td><td>Xlog:gc+region=trace</td><td></td></tr><tr><td>G1PrintRegionLivenessInfo</td><td>Xlog:gc+liveness=trace</td><td></td></tr><tr><td>G1SummarizeConcMark</td><td>Xlog:gc+marking=trace</td><td></td></tr><tr><td>G1SummarizeRSetStats</td><td>Xlog:gc+remset*=trace</td><td></td></tr><tr><td>GCLogFileSize, NumberOfGCLogFiles, UseGCLog File Rotation</td><td><code>Xlog:gc*:file=&lt;file&gt;::filecount=&lt;count&gt;, filesize=&lt;file size in kb&gt;</code></td><td></td></tr><tr><td>PrintAdaptiveSizePolicy</td><td>Xlog:gc+ergo*=trace</td><td></td></tr><tr><td>PrintClassHistogramAfterFullGC</td><td>Xlog:classhisto*=trace</td><td></td></tr><tr><td>PrintClassHistogramBeforeFullGC</td><td>Xlog:classhisto*=trace</td><td></td></tr><tr><td>PrintGCApplicationConcurrentTime</td><td>Xlog:safepoint</td><td></td></tr><tr><td>PrintGCApplicationStoppedTime</td><td>Xlog:safepoint</td><td></td></tr><tr><td>PrintGCDateStamps</td><td>使用time修饰器</td><td></td></tr><tr><td>PrintGCTaskTimeStamps</td><td>Xlog:gc+task=trace</td><td></td></tr><tr><td>PrintGCTimeStamps</td><td>使用uptime修饰器</td><td></td></tr><tr><td>PrintHeapAtGC</td><td>Xlog:gc+heap=debug</td><td></td></tr><tr><td>PrintHeapAtGCExtended</td><td>Xlog:gc+heap=trace</td><td></td></tr><tr><td>PrintJNIGCStalls</td><td>Xlog:gc+jni=debug</td><td></td></tr><tr><td>PrintOldPLAB</td><td>Xlog:gc+plab=trace</td><td></td></tr><tr><td>PrintParallelOldGCPhaseTimes</td><td>Xlog:gc+phases=trace</td><td></td></tr><tr><td>PrintPLAB</td><td>Xlog:gc+plab=trace</td><td></td></tr><tr><td>PrintPromotionFailure</td><td>Xlog:gc+promotion=debug</td><td></td></tr><tr><td>PrintReferenceGC</td><td>Xlog:gc+ref=debug</td><td></td></tr><tr><td>PrintStringDeduplicationStatistics</td><td>Xlog:gc+stringdedup</td><td></td></tr><tr><td>PrintTaskqueue</td><td>Xlog:gc+task+stats=trace</td><td></td></tr><tr><td>PrintTenuringDistribution</td><td>Xlog:gc+age=trace</td><td></td></tr><tr><td>PrintTerminationStats</td><td>Xlog:gc+task+stats=debug</td><td></td></tr><tr><td>PrintTLAB</td><td>Xlog:gc+tlab=trace</td><td></td></tr><tr><td>TraceAdaptiveGCBoundary</td><td>Xlog:heap+ergo=debug</td><td></td></tr><tr><td>TraceDynamicGCThreads</td><td>Xlog:gc+task=trace</td><td></td></tr><tr><td>TraceMetadataHumongousAllocation</td><td>Xlog:ge+metaspace+alloc=debug</td><td></td></tr><tr><td>G1TraceConcRefinement</td><td>Xlog:ge+refine=debug</td><td></td></tr><tr><td>G1TraceEagerReclaimHumongousObjects</td><td>Xlog:gc+humongous=debug</td><td></td></tr><tr><td>G1TraceStringSymbolTableScrubbing</td><td>Xlog:gc+stringtable=trace</td><td></td></tr></tbody></table><h3 id="垃圾收集器参数总结" tabindex="-1"><a class="header-anchor" href="#垃圾收集器参数总结"><span>#### 垃圾收集器参数总结</span></a></h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td></tr><tr><td>UseParNewGC</td><td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收，在JDK9后不再支持</td></tr><tr><td>UseConcMarkSweepGC</td><td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现&quot;Concurrent Mode Failure&quot;失败后的后备收集器使用</td></tr><tr><td>UseParallelGC</td><td>JDK 9之前虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge +Serial Old(PS MarkSweep)的收集器组合进行内存回收</td></tr><tr><td>UseParallelOldGC</td><td>打开此开关后，使用Parallel Scavenge +Parallel Old的收集器组合进行内存回收</td></tr><tr><td>SurvivorRatio</td><td>新生代中Eden区域与Survivor区域的容量比值，默认为8,代表Eden:Survivor=8:1</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1,当超过这个参数值时就进入老年代</td></tr><tr><td>UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td>HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td></tr><tr><td>ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>GCTimeRatio</td><td>GC时间占总时间的比率，默认值为99,即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>MaxGCPauseMillis</td><td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>CMSInitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%,仅在使用CMS收集器时生效</td></tr><tr><td>UseCMSCompactAtFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效，此参数从JDK 9开始废弃</td></tr><tr><td>CMSFullGCsBeforeCompaction</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效，此参数从JDK 9开始废弃</td></tr><tr><td>UseG1GC</td><td>使用G1收集器，这个是JDK 9后的Server模式默认值</td></tr><tr><td>G1HeapRegionSize=n</td><td>设置Region大小，并非最终值</td></tr><tr><td>MaxGCPauseMillis</td><td>设置G1收集过程目标时间，默认值是200ms,不是硬性条件</td></tr><tr><td>G1NewSizePercent</td><td>新生代最小值，默认值是5%</td></tr><tr><td>G1MaxNewSizePercent</td><td>新生代最大值，默认值是60%</td></tr><tr><td>ParallelGCThreads</td><td>用户线程冻结期间并行执行的收集器线程数</td></tr><tr><td>ConcGCThreads=n</td><td>并发标记、并发整理的执行线程数，对不同的收集器，根据其能够并发的阶段，有不同的含义</td></tr><tr><td>InitiatingHeapOccupancyPercent</td><td>设置触发标记周期的Java堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes,包括old+humongous</td></tr><tr><td>UseShenandoahGC</td><td>使用Shenandoah收集器。这个选项在OracleJDK中不被支持，只能在OpenJDK 12或者某些支持Shenandoah的Backport发行版本使用。目前仍然要配合-XX:+UnlockExperimentalVMOptions使用</td></tr><tr><td>ShenandoahGCHeuristics</td><td>Shenandoah何时启动一次GC过程，其可选值有adaptive、static、compact、</td></tr><tr><td>UseZGC</td><td>passive、aggressive使用ZGC收集器，目前仍然要配合-XX:+UnlockExperimentalVMOptions使用</td></tr><tr><td>UseNUMA</td><td>启用NUMA内存分配支持，目前只有Parallel和ZGC支持，以后G1收集器可能也会支持该选项</td></tr></tbody></table><h3 id="内存分配与回收策略" tabindex="-1"><a class="header-anchor" href="#内存分配与回收策略"><span>内存分配与回收策略</span></a></h3><ul><li><p>对象优先在Eden分配</p></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活的对象将进入老年代</p></li><li><p>动态年龄判断</p><p>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p></li><li><p>空间分配担保</p><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看<code>-XX：HandlePromotionFailure</code>参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<code>-XX：HandlePromotionFailure</code>设置不允许冒险，那这时就要改为进行一次Full GC。</p><p>JDK 6 Update 24之后，这个测试结果就有了差异，<code>-XX：HandlePromotionFailure</code>参数不会再影响到虚拟机的空间分配担保策略，DK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。</p></li></ul>',37))])}const C=d(c,[["render",g]]),S=JSON.parse('{"path":"/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8B%EF%BC%89.html","title":"3.垃圾收集器与内存分配策略（下）","lang":"zh-CN","frontmatter":{"order":3,"description":"3.垃圾收集器与内存分配策略（下） 经典垃圾收集器 HotSpot虚拟机的垃圾收集器HotSpot虚拟机的垃圾收集器 两个收集器之间存在连线，就说明它们可以搭配使用 Serial收集器 新生代、标记-复制算法实现、单线程、阻塞 优点 简单而高效，是所有收集器里额外内存消耗（Memory Footprint）最小的。 对于单核处理器或处理器核心数较少的环...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.垃圾收集器与内存分配策略（下）\\",\\"image\\":[\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-5.jpg\\",\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-6.jpg\\",\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-7.jpg\\",\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-8.jpg\\",\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-9.jpg\\",\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-10.jpg\\",\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-11.jpg\\"],\\"dateModified\\":\\"2024-12-30T02:58:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"憨憨十二\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8B%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"一切为了更好的自己"}],["meta",{"property":"og:title","content":"3.垃圾收集器与内存分配策略（下）"}],["meta",{"property":"og:description","content":"3.垃圾收集器与内存分配策略（下） 经典垃圾收集器 HotSpot虚拟机的垃圾收集器HotSpot虚拟机的垃圾收集器 两个收集器之间存在连线，就说明它们可以搭配使用 Serial收集器 新生代、标记-复制算法实现、单线程、阻塞 优点 简单而高效，是所有收集器里额外内存消耗（Memory Footprint）最小的。 对于单核处理器或处理器核心数较少的环..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-5.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-30T02:58:44.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-30T02:58:44.000Z"}]]},"git":{"createdTime":1692084578000,"updatedTime":1735527524000,"contributors":[{"name":"wangkai","username":"wangkai","email":"wangkai@yqun.com.cn","commits":6,"url":"https://github.com/wangkai"},{"name":"hanhan12","username":"hanhan12","email":"1607077440@qq.com","commits":2,"url":"https://github.com/hanhan12"},{"name":"consen3464","username":"consen3464","email":"wangkai@consen.net","commits":4,"url":"https://github.com/consen3464"}]},"readingTime":{"minutes":23.3,"words":6990},"filePathRelative":"books/UnderStandingTheJvm/3.垃圾收集器与内存分配策略（下）.md","autoDesc":true}');export{C as comp,S as data};
