import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as r,o as a}from"./app-IPkfDkxj.js";const n={};function i(o,t){return a(),e("div",null,t[0]||(t[0]=[r(`<h1 id="_6-类文件结构-上" tabindex="-1"><a class="header-anchor" href="#_6-类文件结构-上"><span>6.类文件结构（上）</span></a></h1><h2 id="class类文件的结构" tabindex="-1"><a class="header-anchor" href="#class类文件的结构"><span>Class类文件的结构</span></a></h2><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。</p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</li></ul><table><thead><tr><th>类 型</th><th>名 称</th><th>数 量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。</p><h3 id="魔数与class文件的版本" tabindex="-1"><a class="header-anchor" href="#魔数与class文件的版本"><span>魔数与Class文件的版本</span></a></h3><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p><h3 id="常量池" tabindex="-1"><a class="header-anchor" href="#常量池"><span>常量池</span></a></h3><p>紧接着主、次版本号之后的是常量池入口</p><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始</p><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p><p>而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul><p>截至JDK13，常量表中分别有17种不同类型的常量。这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位，代表着当前常量属于哪种常量类型。</p><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>表示一个动态计算常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>表示一个模块</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>表示一个模块中开放或者导出的包</td></tr></tbody></table><table><thead><tr><th>常 量</th><th>项 目</th><th>类 型</th><th>描 述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>tag</td><td>u1</td><td>值为1</td></tr><tr><td></td><td>length</td><td>u2</td><td>UTF-8编码的字符串占用了字节数</td></tr><tr><td></td><td>bytes</td><td>u1</td><td>长度为length的UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>tag</td><td>u1</td><td>值为3</td></tr><tr><td></td><td>bytes</td><td>u4</td><td>按照高位在前存储的int值</td></tr><tr><td>CONSTANT_Float_info</td><td>tag</td><td>u1</td><td>值为4</td></tr><tr><td></td><td>bytes</td><td>u4</td><td>按照高位在前存储的float值</td></tr><tr><td>CONSTANT_Long_info</td><td>tag</td><td>u1</td><td>值为5</td></tr><tr><td></td><td>bytes</td><td>u8</td><td>按照高位在前存储的long值</td></tr><tr><td>CONSTANT_Double_info</td><td>tag</td><td>u1</td><td>值为6</td></tr><tr><td></td><td>bytes</td><td>u8</td><td>按照高位在前存储的double值</td></tr><tr><td>CONSTANT_Class_info</td><td>tag</td><td>u1</td><td>值为7</td></tr><tr><td></td><td>bytes</td><td>u2</td><td>指向全限定名常量项的索引</td></tr><tr><td>CONSTANT_String_info</td><td>tag</td><td>u1</td><td>值为8</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向字符串字面量的索引</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>tag</td><td>u1</td><td>值为9</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向字段描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>CONSTANT_Methodref_info</td><td>tag</td><td>u1</td><td>值10</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向声明方法的类描述符CONSTANT_Class_info的索引项</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>tag</td><td>u1</td><td>值11</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向声明方法的接口描述符CONSTANT_Class_info的索引项</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>tag</td><td>u1</td><td>值为12</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向该字段或方法名称常量项的索引</td></tr><tr><td></td><td>index</td><td>u2</td><td>指向该字段或方法描述符常量项的索引</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>tag</td><td>u1</td><td>值为15</td></tr><tr><td></td><td>reference_kind</td><td>u1</td><td>值必须在1至9之间(包括1和9).它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</td></tr><tr><td></td><td>reference_index</td><td>u2</td><td>值必须是对常量池的有效索引</td></tr><tr><td>CONSTANT_MethodType_info</td><td>tag</td><td>u1</td><td>值为16</td></tr><tr><td></td><td>descriptor_index</td><td>u2</td><td>值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANTUtf8_info结构，表示方法的描述符</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>tag</td><td>u1</td><td>值为17</td></tr><tr><td></td><td>bootstrap_method_attr_index</td><td>u2</td><td>值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr><td></td><td>name_and_type_index</td><td>u2</td><td>值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANTNameAndType_info结构，表示方法名和方法描述符</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>tag</td><td>u1</td><td>值为18</td></tr><tr><td></td><td>bootstrap_method_attr_index</td><td>u1</td><td>值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr><td></td><td>name_and_type_index</td><td>u2</td><td>值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td></tr><tr><td>CONSTANT_Module_info</td><td>tag</td><td>u1</td><td>值为19</td></tr><tr><td></td><td>name_index</td><td>u2</td><td>值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示模块名字</td></tr><tr><td>CONSTANT_Package_info</td><td>tag</td><td>u1</td><td>值为20</td></tr><tr><td></td><td>name_index</td><td>u2</td><td>值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示包名称</td></tr></tbody></table><h3 id="访问标志" tabindex="-1"><a class="header-anchor" href="#访问标志"><span>访问标志</span></a></h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或 者接口层次的访问信息</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final,只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语义在JDK 1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK1.0.2之后编译出来的类的这个标志都必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>标识这是一个模块</td></tr></tbody></table><p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个[1]，没有使用到的标志位要求一律为零。</p><h3 id="类索引、父类索引与接口索引集合" tabindex="-1"><a class="header-anchor" href="#类索引、父类索引与接口索引集合"><span>类索引、父类索引与接口索引集合</span></a></h3><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。</p><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm6-1.jpg" alt="类索引查找全限定名的过程" tabindex="0" loading="lazy"><figcaption>类索引查找全限定名的过程</figcaption></figure><p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p><h3 id="字段表集合" tabindex="-1"><a class="header-anchor" href="#字段表集合"><span>字段表集合</span></a></h3><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>字段表结构:</p><table><thead><tr><th>类 型</th><th>名 称</th><th>数 量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义</p><p>字段访问标志:</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含 义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table><p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><blockquote><p><strong>全限定名</strong>：把类全名中的“.”替换成了“/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束</p><p><strong>简单名称</strong>：没有类型和参数修饰的方法或者字段名称</p><p><strong>描述符</strong>： 描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p><ul><li><p>基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型byte</td></tr><tr><td>C</td><td>基本类型char</td></tr><tr><td>D</td><td>基本类型double</td></tr><tr><td>F</td><td>基本类型float</td></tr><tr><td>I</td><td>基本类型int</td></tr><tr><td>J</td><td>基本类型long</td></tr><tr><td>S</td><td>基本类型short</td></tr><tr><td>Z</td><td>基本类型boolean</td></tr><tr><td>V</td><td>特殊类型void</td></tr><tr><td>L</td><td>对象类型，如Ljava/lang/Objet;</td></tr></tbody></table><p>void类型在《Java虚拟机规范》之中单独列出为“VoidDescriptor”</p></li><li><p>数组类型，每一维度将使用一个前置的“[”字符来描述</p><p>eg:</p><pre><code>java.lang.String[][] -&gt; [[Ljava/lang/String；

int[] -&gt; [I
</code></pre></li><li><p>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内</p><p>eg:</p><pre><code>void inc() -&gt; ()V

java.lang.String toString() -&gt; ()Ljava/lang/String；

int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex) -&gt; ([CII[CIII)I
</code></pre></li></ul></blockquote><p>字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。</p><p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。</p><h3 id="方法表集合" tabindex="-1"><a class="header-anchor" href="#方法表集合"><span>方法表集合</span></a></h3><p>方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）。</p><p>volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</p><table><thead><tr><th>标志名称</th><th>标 志 值</th><th>含 义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x008</td><td>方法是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否为final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是不是由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICT</td><td>0x0800</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生</td></tr></tbody></table><p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面</p><p>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出 现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器<code>&lt;clinit&gt;()</code>方法和实例构造器<code>&lt;init&gt;()</code>方法。</p><p>在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p><h3 id="属性表集合" tabindex="-1"><a class="header-anchor" href="#属性表集合"><span>属性表集合</span></a></h3><p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p><p>《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件</p><p>虚拟机规范预定义的属性:</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>由final关键字定义的常量值</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常列表</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标示这个类所在的外围方法</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK6中新增的属性，供新的类型检查验证器(Type Checker)检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>JDK5中新增的属性，用于支持范型情况下的方法签名。在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variables)或参数化类型(Parameterized Types),则Signature属性会为它记录泛型签名信息。由于Java的范型采用擦除法实现，为了避免类型信息被擦除后导致签名混乱，需要这个属性记录范型中的相关信息</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>JDK5中新增的属性，用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号，JSR 45提案为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以用于存储这个标准所新加入的调试信息</td></tr><tr><td>Synthetic</td><td>类、方法表、字段表</td><td>标识方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>JDK5中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK5中新增的属性，为动态注解提供支持。该属性用于指明哪些注解是运行时(实际上运行时就是进行反射调用)可见的</td></tr><tr><td>RuntimelnvisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK5中新增的属性，与RuntimeVisibleAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotations</td><td>方法表</td><td>JDK5中新增的属性，作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法参数</td></tr><tr><td>RuntimelnvisibleParameterAnnotations</td><td>方法表</td><td>JDK5中新增的属性，作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象为方法参数</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>JDK5中新增的属性，用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>JDK 7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符</td></tr><tr><td>RuntimeVisibleTypeAnnotations</td><td>类、方法表、字段表，Code属性</td><td>JDK8中新增的属性，为实现JSR 308中新增的类型注解提供的支持，用于指明哪些类注解是运行时(实际上运行时就是进行反射调用)可见的</td></tr><tr><td>RuntimelnvisibleTypeAnnotations</td><td>类、方法表、字段表，Code属性</td><td>JDK8中新增的属性，为实现JSR 308中新增的类型注解提供的支持，与RuntimeVisibleTypeAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的</td></tr><tr><td>MethodParameters</td><td>方法表</td><td>JDK8中新增的属性，用于支持(编译时加上-parameters参数)将方法名称编译进Class文件中，并可运行时获取。此前要获取方法名称(典型的如IDE的代码提示)只能通过JavaDoc中得到</td></tr><tr><td>Module</td><td>类</td><td>JDK 9中新增的属性，用于记录一个Module的名称以及相关信息(requires、exports、opens、uses、provides)</td></tr><tr><td>ModulePackages</td><td>类</td><td>JDK9中新增的属性，用于记录一个模块中所有被exports或者opens的包</td></tr><tr><td>ModuleMainClass</td><td>类</td><td>JDK 9中新增的属性，用于指定一个模块的主类</td></tr><tr><td>NestHost</td><td>类</td><td>JDK 11中新增的属性，用于支持嵌套类(Java中的内部类)的反射和访问控制的API,一个内部类通过该属性得知自己的宿主类</td></tr><tr><td>NestMembers</td><td>类</td><td>JDK 11中新增的属性，用于支持嵌套类(Java中的内部类)的反射和访问控制的API,一个宿主类通过该属性得知自己有哪些内部类</td></tr></tbody></table><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p><p>属性表结构:</p><table><thead><tr><th>类 型</th><th>名 称</th><th>数 量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>ul</td><td>info</td><td>attribute_length</td></tr></tbody></table><h4 id="code属性" tabindex="-1"><a class="header-anchor" href="#code属性"><span>Code属性</span></a></h4><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。</p><h2 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>TODO</span></a></h2>`,57)]))}const p=d(n,[["render",i],["__file","6.类文件结构（上）.html.vue"]]),_=JSON.parse('{"path":"/books/UnderStandingTheJvm/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89.html","title":"6.类文件结构（上）","lang":"zh-CN","frontmatter":{"description":"6.类文件结构（上） Class类文件的结构 Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/my-docs/books/UnderStandingTheJvm/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"一切为了更好的自己"}],["meta",{"property":"og:title","content":"6.类文件结构（上）"}],["meta",{"property":"og:description","content":"6.类文件结构（上） Class类文件的结构 Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm6-1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-02T05:37:18.000Z"}],["meta",{"property":"article:author","content":"憨憨十二"}],["meta",{"property":"article:modified_time","content":"2024-09-02T05:37:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.类文件结构（上）\\",\\"image\\":[\\"https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm6-1.jpg\\"],\\"dateModified\\":\\"2024-09-02T05:37:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"憨憨十二\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Class类文件的结构","slug":"class类文件的结构","link":"#class类文件的结构","children":[{"level":3,"title":"魔数与Class文件的版本","slug":"魔数与class文件的版本","link":"#魔数与class文件的版本","children":[]},{"level":3,"title":"常量池","slug":"常量池","link":"#常量池","children":[]},{"level":3,"title":"访问标志","slug":"访问标志","link":"#访问标志","children":[]},{"level":3,"title":"类索引、父类索引与接口索引集合","slug":"类索引、父类索引与接口索引集合","link":"#类索引、父类索引与接口索引集合","children":[]},{"level":3,"title":"字段表集合","slug":"字段表集合","link":"#字段表集合","children":[]},{"level":3,"title":"方法表集合","slug":"方法表集合","link":"#方法表集合","children":[]},{"level":3,"title":"属性表集合","slug":"属性表集合","link":"#属性表集合","children":[{"level":4,"title":"Code属性","slug":"code属性","link":"#code属性","children":[]}]}]},{"level":2,"title":"TODO","slug":"todo","link":"#todo","children":[]}],"git":{"createdTime":1693477853000,"updatedTime":1725255438000,"contributors":[{"name":"consen3464","email":"wangkai@consen.net","commits":3}]},"readingTime":{"minutes":16.92,"words":5077},"filePathRelative":"books/UnderStandingTheJvm/6.类文件结构（上）.md","localizedDate":"2023年8月31日","autoDesc":true}');export{p as comp,_ as data};
