<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.43" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my-docs/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8A%EF%BC%89.html"><meta property="og:site_name" content="一切为了更好的自己"><meta property="og:title" content="3.垃圾收集器与内存分配策略（上）"><meta property="og:description" content="3.垃圾收集器与内存分配策略（上） 判断对象存活 引用计数法 存在引用对象时，计数器加一。计数器为零时，判定其死亡。 优点 简单、高效。 缺点 无法处理一些特殊情况，需要许多额外的特殊判断。如：对象间的相互调用。 可达性分析 从一系列称为“GC Roots”的根对象开始，根据引用关系向下搜索，未经过的对象即未被使用的对象。 GC Roots对象 虚拟机..."><meta property="og:type" content="article"><meta property="og:image" content="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-1.jpg"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-09-02T05:37:18.000Z"><meta property="article:author" content="憨憨十二"><meta property="article:modified_time" content="2024-09-02T05:37:18.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"3.垃圾收集器与内存分配策略（上）","image":["https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-1.jpg","https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-2.jpg","https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-3.jpg","https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-4.jpg"],"dateModified":"2024-09-02T05:37:18.000Z","author":[{"@type":"Person","name":"憨憨十二","url":"https://mister-hope.com"}]}</script><title>3.垃圾收集器与内存分配策略（上） | 一切为了更好的自己</title><meta name="description" content="3.垃圾收集器与内存分配策略（上） 判断对象存活 引用计数法 存在引用对象时，计数器加一。计数器为零时，判定其死亡。 优点 简单、高效。 缺点 无法处理一些特殊情况，需要许多额外的特殊判断。如：对象间的相互调用。 可达性分析 从一系列称为“GC Roots”的根对象开始，根据引用关系向下搜索，未经过的对象即未被使用的对象。 GC Roots对象 虚拟机...">
    <link rel="preload" href="/my-docs/assets/style-Cc-EbHKZ.css" as="style"><link rel="stylesheet" href="/my-docs/assets/style-Cc-EbHKZ.css">
    <link rel="modulepreload" href="/my-docs/assets/app-IPkfDkxj.js"><link rel="modulepreload" href="/my-docs/assets/3.垃圾收集器与内存分配策略（上）.html-DOojsy_g.js"><link rel="modulepreload" href="/my-docs/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/my-docs/assets/index.html-Roc1x59k.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-6X9t5qpu.js" as="script"><link rel="prefetch" href="/my-docs/assets/2023.html-CZcJbhdh.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-BLJjaEnE.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-BWMmt9_Q.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-BFkKlz8G.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-3g_tXqhW.js" as="script"><link rel="prefetch" href="/my-docs/assets/10.前端编译与优化.html-xpAp087Y.js" as="script"><link rel="prefetch" href="/my-docs/assets/11.后端编译与优化.html-Xs_v6BVk.js" as="script"><link rel="prefetch" href="/my-docs/assets/2.Java内存区域与内存溢出异常.html-sguZT_xH.js" as="script"><link rel="prefetch" href="/my-docs/assets/3.垃圾收集器与内存分配策略（下）.html-CvPGtoPK.js" as="script"><link rel="prefetch" href="/my-docs/assets/4.虚拟机性能监控、故障处理工具.html-BURKEJxN.js" as="script"><link rel="prefetch" href="/my-docs/assets/5.调优案例分析与实战.html-DdFwZo66.js" as="script"><link rel="prefetch" href="/my-docs/assets/6.类文件结构（上）.html-bMezDIIg.js" as="script"><link rel="prefetch" href="/my-docs/assets/6.类文件结构（下）.html-BR-9LCfV.js" as="script"><link rel="prefetch" href="/my-docs/assets/7.虚拟机类加载机制.html-D6upEAca.js" as="script"><link rel="prefetch" href="/my-docs/assets/8.虚拟机字节码执行引擎.html-CHO3Bc_W.js" as="script"><link rel="prefetch" href="/my-docs/assets/9.类加载及执行子系统的案例与实战.html-BEJe7Ncf.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-je-vdzFE.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-BeJJBQWv.js" as="script"><link rel="prefetch" href="/my-docs/assets/dump.html-CgS7EZ3W.js" as="script"><link rel="prefetch" href="/my-docs/assets/logs.html-CteEoTLH.js" as="script"><link rel="prefetch" href="/my-docs/assets/0.redis7.html-D8dTCNAM.js" as="script"><link rel="prefetch" href="/my-docs/assets/1.十大数据类型.html-DetU5pF8.js" as="script"><link rel="prefetch" href="/my-docs/assets/2.持久化.html-Cj-6GcFe.js" as="script"><link rel="prefetch" href="/my-docs/assets/3.事务.html-D0FP5PwK.js" as="script"><link rel="prefetch" href="/my-docs/assets/4.管道.html-B3H0WI8v.js" as="script"><link rel="prefetch" href="/my-docs/assets/5.发布与订阅.html-DGZVcgfp.js" as="script"><link rel="prefetch" href="/my-docs/assets/6.复制.html-BXO5kx7f.js" as="script"><link rel="prefetch" href="/my-docs/assets/7.哨兵.html-BgjEihqV.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-CAhMCF-2.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-WY8-PpYT.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-CDxqUD9S.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-wEn3fTf7.js" as="script"><link rel="prefetch" href="/my-docs/assets/no.html-Bggz8Mf2.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-BjxWTrKZ.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-6Q8zK8Bd.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-WkXnwUCZ.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-Jvc2997A.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-Bito5Fo8.js" as="script"><link rel="prefetch" href="/my-docs/assets/SpringSecurity.html-B-4pbTrz.js" as="script"><link rel="prefetch" href="/my-docs/assets/demo.html-_U9HoCj_.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-C4Md3jw-.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-DHIr7USm.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-CQfPShe9.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-aNDDDL4S.js" as="script"><link rel="prefetch" href="/my-docs/assets/string-compression.html-IQPW5i69.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-BVtf9Xg2.js" as="script"><link rel="prefetch" href="/my-docs/assets/install.html-DfRGkxGy.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-2TimMen1.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-CbUDOSOT.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-DpohJUce.js" as="script"><link rel="prefetch" href="/my-docs/assets/arthas.html-DqXfZ7t8.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-BxbtaanI.js" as="script"><link rel="prefetch" href="/my-docs/assets/drone.html-CbMyU2PH.js" as="script"><link rel="prefetch" href="/my-docs/assets/nginx.html-DVjCG_xK.js" as="script"><link rel="prefetch" href="/my-docs/assets/podman-compose.html-Bm6gmrrd.js" as="script"><link rel="prefetch" href="/my-docs/assets/podman.html-CQmzNTKG.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-D-H00zGl.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-XXSTSKO_.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-zu40gkWN.js" as="script"><link rel="prefetch" href="/my-docs/assets/basis.html-Ds0kWP9C.js" as="script"><link rel="prefetch" href="/my-docs/assets/404.html-B4CKWbuD.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-Dlv9CWZJ.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-CbO2TWOo.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-BOlVANES.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-CMw-ULdl.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-DG4ffYH3.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-DJf5TL8z.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-Cgvzxj0k.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-CZl1qWB6.js" as="script"><link rel="prefetch" href="/my-docs/assets/index.html-rLTebBeh.js" as="script"><link rel="prefetch" href="/my-docs/assets/photoswipe.esm-GXRgw7eJ.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/my-docs/"><img class="vp-nav-logo" src="/my-docs/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">一切为了更好的自己</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link vp-link" href="/my-docs/" aria-label="主页"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link vp-link" href="/my-docs/java/" aria-label="Java"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Java<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link active vp-link" href="/my-docs/books/" aria-label="Books"><!---->Books<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link vp-link" href="/my-docs/dbs/" aria-label="数据库"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>数据库<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link vp-link" href="/my-docs/linux/" aria-label="Linux"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Linux<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link vp-link" href="/my-docs/interview/" aria-label="面试"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>面试<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="LeetCode"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>LeetCode<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link vp-link" href="/my-docs/leetcode/daily/" aria-label="Daily"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Daily<!----></a></li><li class="vp-dropdown-item"><a class="route-link vp-link" href="/my-docs/leetcode/leetcode-75/" aria-label="Leetcode-75"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Leetcode-75<!----></a></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/knightio/my-docs" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">深入理解Java虚拟机</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/2.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html" aria-label="2.Java内存区域与内存溢出异常"><!---->2.Java内存区域与内存溢出异常<!----></a></li><li><a class="route-link active vp-link vp-sidebar-link vp-sidebar-page active" href="/my-docs/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8A%EF%BC%89.html" aria-label="3.垃圾收集器与内存分配策略（上）"><!---->3.垃圾收集器与内存分配策略（上）<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8B%EF%BC%89.html" aria-label="3.垃圾收集器与内存分配策略（下）"><!---->3.垃圾收集器与内存分配策略（下）<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/4.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html" aria-label="4.虚拟机性能监控、故障处理工具"><!---->4.虚拟机性能监控、故障处理工具<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/5.%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98.html" aria-label="5.调优案例分析与实战"><!---->5.调优案例分析与实战<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89.html" aria-label="6.类文件结构（上）"><!---->6.类文件结构（上）<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8B%EF%BC%89.html" aria-label="6.类文件结构（下）"><!---->6.类文件结构（下）<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" aria-label="7.虚拟机类加载机制"><!---->7.虚拟机类加载机制<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/8.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html" aria-label="8.虚拟机字节码执行引擎"><!---->8.虚拟机字节码执行引擎<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/9.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98.html" aria-label="9.类加载及执行子系统的案例与实战"><!---->9.类加载及执行子系统的案例与实战<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/10.%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" aria-label="10.前端编译与优化"><!---->10.前端编译与优化<!----></a></li><li><a class="route-link vp-link vp-sidebar-link vp-sidebar-page" href="/my-docs/books/UnderStandingTheJvm/11.%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" aria-label="11.后端编译与优化"><!---->11.后端编译与优化<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">高性能MySQL</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->3.垃圾收集器与内存分配策略（上）</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mister-hope.com" target="_blank" rel="noopener noreferrer">憨憨十二</a></span><span property="author" content="憨憨十二"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-08-15T07:29:38.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 14 分钟</span><meta property="timeRequired" content="PT14M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#判断对象存活">判断对象存活</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#引用计数法">引用计数法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#可达性分析">可达性分析</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#回收方法区">回收方法区</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#垃圾回收算法">垃圾回收算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#分代收集理论">分代收集理论</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#标记-清除算法">标记-清除算法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#标记-复制算法">标记-复制算法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#标记-整理算法">标记-整理算法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#hotspot的算法细节实现">HotSpot的算法细节实现</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#根节点枚举">根节点枚举</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#安全点">安全点</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#安全区域">安全区域</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#记忆集与卡表">记忆集与卡表</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#写屏障">写屏障</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#并发的可达性分析">并发的可达性分析</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="_3-垃圾收集器与内存分配策略-上" tabindex="-1"><a class="header-anchor" href="#_3-垃圾收集器与内存分配策略-上"><span>3.垃圾收集器与内存分配策略（上）</span></a></h1><h2 id="判断对象存活" tabindex="-1"><a class="header-anchor" href="#判断对象存活"><span>判断对象存活</span></a></h2><h3 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法"><span>引用计数法</span></a></h3><p>存在引用对象时，计数器加一。计数器为零时，判定其死亡。</p><ul><li><p>优点</p><p>简单、高效。</p></li><li><p>缺点</p><p>无法处理一些特殊情况，需要许多额外的特殊判断。如：对象间的相互调用。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>  objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
  objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>

  objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      
  <span class="token class-name">Sysytem</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//会被回收掉</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="可达性分析" tabindex="-1"><a class="header-anchor" href="#可达性分析"><span>可达性分析</span></a></h3><p>从一系列称为“GC Roots”的根对象开始，根据引用关系向下搜索，未经过的对象即未被使用的对象。</p><h4 id="gc-roots对象" tabindex="-1"><a class="header-anchor" href="#gc-roots对象"><span>GC Roots对象</span></a></h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用对象，如当前正在运行的方法使用到的参数、局部变量、临时变量等。</li><li>方法区中类静态属性应用的对象，如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，如字符常量出（String Table）里的引用。</li><li>在本地方法栈JNI(Native方法)引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointException、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><h4 id="引用关系" tabindex="-1"><a class="header-anchor" href="#引用关系"><span>引用关系</span></a></h4><ul><li><p>强引用</p><p><code>Object obj = new Object()</code></p></li><li><p>软引用</p><p>还有用，但非必须的对象。在发生内存溢出异常前，被列为回收范围内进行二次回收。<code>SoftReference</code>类实现。</p></li><li><p>弱引用</p><p>弱于软引用。当垃圾收集器开始工作，无论当前内存是否足够，都会被回收。<code>WeakReference</code>类实现。</p></li><li><p>虚引用</p><p>最弱的一种引用。设置虚引用关联的唯一目的是为了能在此对象被回收是收到一个系统通知。<code>PhantomReference</code>类实现。</p></li></ul><h4 id="缓刑" tabindex="-1"><a class="header-anchor" href="#缓刑"><span>缓刑</span></a></h4><p>真正宣告一个对象死亡，至少要经历两次标记过程：</p><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>，随后进行一次筛选，筛选的条件是此对象<strong>是否有必要执行finalize()方法</strong>。</p><ul><li><p>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p></li><li><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p></li></ul><p>finalize()方法是对象自救的最后一次机会，稍后收集器将对F-Queue中的对象进行<strong>第二次小规模的标记</strong>。</p><blockquote><p>任何一个对象的finalize()方法都只会被系统<strong>自动</strong>调用一次</p></blockquote><h3 id="回收方法区" tabindex="-1"><a class="header-anchor" href="#回收方法区"><span>回收方法区</span></a></h3><p>主要回收两部分内容：废弃的常量和不再使用的类型</p><ul><li><p>废弃的常量</p><p>没有任意地方引用的常量</p></li><li><p>不再使用的类型</p><ul><li>该类所有的实例都已经被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用</li></ul><blockquote><p>并不是和对象一样，没有引用了就必然会回收。</p></blockquote></li></ul><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h2><h3 id="分代收集理论" tabindex="-1"><a class="header-anchor" href="#分代收集理论"><span>分代收集理论</span></a></h3><p>分代理论建立在两大假说之上：</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p>设计者一般至少会把Java堆划分为<strong>新生代（Young Generation）<strong>和</strong>老年代（Old Generation）</strong> 两个区域。</p><p>存在问题：对象不是孤立的，对象之间会存在跨代引用。</p><ul><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p><p>只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。</p><blockquote><p><strong>针对不同分代收集类型</strong></p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： <ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li></ul></li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li></ul></blockquote><h3 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法"><span>标记-清除算法</span></a></h3><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来。</p><p>缺点：</p><ol><li>执行效率不稳定</li><li>内存空间的碎片化问题</li></ol><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-1.jpg" alt="“标记-清除”算法示意图" tabindex="0" loading="lazy"><figcaption>“标记-清除”算法示意图</figcaption></figure><h3 id="标记-复制算法" tabindex="-1"><a class="header-anchor" href="#标记-复制算法"><span>标记-复制算法</span></a></h3><p>解决标记-清除算法面对大量可回收对象时执行效率低的问题</p><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>缺点：</p><p>过多的空间浪费</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-2.jpg" alt="“标记-复制”算法示意图" tabindex="0" loading="lazy"><figcaption>“标记-复制”算法示意图</figcaption></figure><p>新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。</p><h4 id="appel式回收" tabindex="-1"><a class="header-anchor" href="#appel式回收"><span>Appel式回收</span></a></h4><p>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新 生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代会被“浪费”的。</p><blockquote><p><strong>“逃生门”</strong></p><p>当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p></blockquote><h3 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法"><span>标记-整理算法</span></a></h3><p>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p><p>缺点：</p><p>在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-3.jpg" alt="“标记-整理”算法示意图" tabindex="0" loading="lazy"><figcaption>“标记-整理”算法示意图</figcaption></figure><p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p><h2 id="hotspot的算法细节实现" tabindex="-1"><a class="header-anchor" href="#hotspot的算法细节实现"><span>HotSpot的算法细节实现</span></a></h2><h3 id="根节点枚举" tabindex="-1"><a class="header-anchor" href="#根节点枚举"><span>根节点枚举</span></a></h3><p>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</p><p>由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</p><p>在HotSpot的解决方案里，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在<strong>特定的位置</strong>记录下栈里和寄存器里哪些位置是引用。</p><h3 id="安全点" tabindex="-1"><a class="header-anchor" href="#安全点"><span>安全点</span></a></h3><p>上文中的<strong>特定的位置</strong>，被称为安全点。用户程序执行时，强制要求必须执行到达安全点后才能够暂停，开始垃圾收集。</p><p>安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是<strong>指令序列的复用</strong>，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p><blockquote><p>由于安全点设置会有损耗，JIT会对安全点的设置进行优化。</p></blockquote><h4 id="到达安全点方式" tabindex="-1"><a class="header-anchor" href="#到达安全点方式"><span>到达安全点方式</span></a></h4><ul><li><p>抢先式中断（Preemptive Suspension）</p><p>系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。(没什么虚拟机在使用)</p></li><li><p>主动式中断（Voluntary Suspension）</p><p>简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</p><p>轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p></li></ul><h3 id="安全区域" tabindex="-1"><a class="header-anchor" href="#安全区域"><span>安全区域</span></a></h3><p>用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（Safe Region）来解决。</p><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中<strong>任意地方</strong>开始垃圾收集<strong>都是安全的</strong>。我们也可以把安全区域看作被扩展拉伸了的安全点。</p><p>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p><h3 id="记忆集与卡表" tabindex="-1"><a class="header-anchor" href="#记忆集与卡表"><span>记忆集与卡表</span></a></h3><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的<strong>抽象</strong>数据结构。</p><blockquote><p>抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。</p></blockquote><p>记录精度：</p><ul><li><p>字长精度：</p><p>每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</p></li><li><p>对象精度：</p><p>每个记录精确到一个对象，该对象里有字段含有跨代指针。</p></li><li><p>卡精度：</p><p>每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p></li></ul><p>第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集。</p><p>卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。卡表最简单的形式可以只是一个<strong>字节数组</strong>，而HotSpot虚拟机确实也是这样做的。</p><p>卡表中的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数。</p><h3 id="写屏障" tabindex="-1"><a class="header-anchor" href="#写屏障"><span>写屏障</span></a></h3><p>在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。</p><blockquote><p>不是解决并发乱序执行问题的“写屏障”</p></blockquote><p>赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）。</p><p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用。</p><p>除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。</p><p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。</p><h3 id="并发的可达性分析" tabindex="-1"><a class="header-anchor" href="#并发的可达性分析"><span>并发的可达性分析</span></a></h3><p>并发的可能性分析，可能出现两种后果。一种是把原本消亡的对象错误标记为存活，其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果。</p><figure><img src="https://docs-r2.hanhan12.cc/Java/JVM/UTJVM/jvm3-4.jpg" alt="并发出现“对象消失”问题的示意" tabindex="0" loading="lazy"><figcaption>并发出现“对象消失”问题的示意</figcaption></figure><blockquote><p><strong>三色标记（Tri-color Marking）</strong></p><ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li><li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li></ul></blockquote><p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</p><ul><li><p>增量更新要破坏的是第一个条件</p><p>当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p></li><li><p>原始快照要破坏的是第二个条件</p><p>当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p></li></ul><blockquote><p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。</p></blockquote></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="vp-link vp-external-link-icon vp-meta-label" href="https://github.com/knightio/my-docs/edit/main/src/books/UnderStandingTheJvm/3.垃圾收集器与内存分配策略（上）.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><!----></div></footer><nav class="vp-page-nav"><a class="route-link vp-link prev" href="/my-docs/books/UnderStandingTheJvm/2.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html" aria-label="2.Java内存区域与内存溢出异常"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->2.Java内存区域与内存溢出异常</div></a><a class="route-link vp-link next" href="/my-docs/books/UnderStandingTheJvm/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%8B%EF%BC%89.html" aria-label="3.垃圾收集器与内存分配策略（下）"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">3.垃圾收集器与内存分配策略（下）<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><a href='https://beian.miit.gov.cn/' target='_blank'>京ICP备2023018079号</a></div><div class="vp-copyright">Copyright © 2024 憨憨十二 </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/my-docs/assets/app-IPkfDkxj.js" defer></script>
  </body>
</html>
